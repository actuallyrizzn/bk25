"""
AppleScript Generator

Generates robust AppleScript automation for macOS
Focus: macOS apps, system automation, workflow integration
"""

import re
from typing import Dict, Any
from .base import BaseGenerator


class AppleScriptGenerator(BaseGenerator):
    """AppleScript generator"""
    
    def __init__(self):
        super().__init__("applescript", ".scpt")
    
    def build_generation_prompt(self, description: str, options: Dict[str, Any] = None) -> str:
        """Build generation prompt for AppleScript"""
        options = options or {}
        
        prompt = f"""Generate an AppleScript for the following automation task:

TASK: {description}

REQUIREMENTS:
- Write production-ready AppleScript code
- Include proper error handling with try/on error blocks
- Add comments explaining each major step
- Use proper AppleScript syntax and conventions
- Include user feedback with display notification or display dialog
- Make the script robust and reliable
- Handle common macOS application interactions

SCRIPT STRUCTURE:
1. Script header with description
2. Main logic with error handling
3. User feedback and notifications
4. Clean completion

EXAMPLE FORMAT:
```applescript
-- Script Name: Brief description
-- Description: Detailed description of what this script does
-- Generated by BK25 - Enterprise automation without enterprise complexity

try
    display notification "Starting automation..." with title "BK25 Automation"
    
    -- Main automation logic here
    
    display notification "Automation completed successfully!" with title "BK25 Automation"
    
on error errorMessage
    display dialog "Automation failed: " & errorMessage buttons {{"OK"}} default button "OK" with icon stop
end try
```

COMMON PATTERNS:
- Use "tell application" blocks for app interactions
- Use "with timeout" for long-running operations
- Use proper AppleScript record syntax
- Include user confirmations for destructive operations
- Use system events for UI automation when needed

Generate the complete AppleScript now:"""
        
        return prompt
    
    def parse_generated_script(self, generated_text: str) -> Dict[str, Any]:
        """Parse generated script and extract components"""
        # Extract AppleScript code block
        script = self.extract_code_block(generated_text, "applescript")
        
        # Clean up any extra formatting
        script = self.cleanup_script(script)
        
        # Extract documentation from script comments
        documentation = self.extract_documentation(script)
        
        # Generate filename
        filename = self.generate_filename(script)
        
        return {
            "script": script,
            "documentation": documentation,
            "filename": filename
        }
    
    def cleanup_script(self, script: str) -> str:
        """Clean up generated script"""
        # Remove any leading/trailing whitespace
        script = script.strip()
        
        # Ensure proper line endings
        script = self.clean_line_endings(script)
        
        # Add header comment if not present
        if not script.startswith('--'):
            script = f"-- Generated by BK25 - Enterprise automation without enterprise complexity\n\n{script}"
        
        return script
    
    def extract_documentation(self, script: str) -> str:
        """Extract documentation from script"""
        lines = script.split('\n')
        doc_lines = []
        
        for line in lines:
            trimmed_line = line.strip()
            
            # AppleScript comments start with --
            if trimmed_line.startswith('--'):
                comment = trimmed_line[2:].strip()
                # Skip empty comments and the BK25 generated comment
                if comment and 'Generated by BK25' not in comment:
                    doc_lines.append(comment)
            
            # Stop collecting documentation after the first non-comment, non-empty line
            elif trimmed_line and not trimmed_line.startswith('--'):
                break
        
        return '\n'.join(doc_lines) if doc_lines else "AppleScript automation"
    
    def generate_filename(self, script: str) -> str:
        """Generate appropriate filename for AppleScript"""
        # Try to extract from script name comments
        lines = script.split('\n')
        for line in lines[:5]:  # Check first 5 lines
            line = line.strip()
            if line.startswith('-- Script Name:') or line.startswith('--Script Name:'):
                name_match = re.search(r'-- ?Script Name:\s*([^-\n]+)', line, re.IGNORECASE)
                if name_match:
                    name = name_match.group(1).strip()
                    # Clean up name for filename
                    name = re.sub(r'[^\w\s-]', '', name)
                    name = re.sub(r'\s+', '_', name)
                    if name:
                        return f"{name.lower()}.scpt"
        
        # Fallback to parent method
        return super().generate_filename(script)
    
    def validate_script_syntax(self, script: str) -> bool:
        """Basic AppleScript syntax validation"""
        if not super().validate_script_syntax(script):
            return False
        
        # Check for basic AppleScript patterns
        applescript_indicators = [
            r'tell application',
            r'on error',
            r'try\s*$',
            r'end try',
            r'display notification',
            r'display dialog',
            r'set \w+ to',
        ]
        
        for pattern in applescript_indicators:
            if re.search(pattern, script, re.IGNORECASE):
                return True
        
        return False
    
    def get_common_patterns(self) -> Dict[str, str]:
        """Get common AppleScript patterns and templates"""
        return {
            "application_interaction": '''
tell application "Finder"
    activate
    -- Application-specific commands here
end tell
            '''.strip(),
            
            "error_handling": '''
try
    -- Main logic here
    display notification "Operation completed successfully" with title "Success"
on error errorMessage
    display dialog "Operation failed: " & errorMessage buttons {"OK"} default button "OK" with icon stop
end try
            '''.strip(),
            
            "user_interaction": '''
set userResponse to display dialog "Please confirm this action" buttons {"Cancel", "OK"} default button "OK"
if button returned of userResponse is "OK" then
    -- Proceed with action
    display notification "Action confirmed" with title "Status"
else
    -- User cancelled
    return
end if
            '''.strip(),
            
            "file_operations": '''
set filePath to choose file with prompt "Select a file:"
set fileName to name of (info for filePath)
set fileContents to read filePath

-- Process file contents
display notification "File processed: " & fileName with title "File Operation"
            '''.strip(),
            
            "system_events": '''
tell application "System Events"
    -- UI automation commands
    keystroke "Hello World"
    delay 1
    key code 36 -- Return key
end tell
            '''.strip()
        }
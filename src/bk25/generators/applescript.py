from __future__ import annotations

from typing import Any, Dict
import re


class AppleScriptGenerator:
    platform = "applescript"
    file_extension = ".scpt"

    def build_generation_prompt(self, description: str, options: Dict[str, Any]) -> str:
        return f"""Generate an AppleScript for the following automation task:

TASK: {description}

REQUIREMENTS:
- Write production-ready AppleScript code
- Include proper error handling with try/on error blocks
- Add comments explaining each major step
- Use proper AppleScript syntax and conventions
- Include user feedback with display notification or display dialog
- Make the script robust and reliable
- Handle common macOS application interactions

SCRIPT STRUCTURE:
1. Script header with description
2. Main logic with error handling
3. User feedback and notifications
4. Clean completion

EXAMPLE FORMAT:
```applescript
-- Script Name: Brief description
-- Description: Detailed description of what this script does
-- Generated by BK25 - Enterprise automation without enterprise complexity

try
    display notification "Starting automation..." with title "BK25 Automation"
    
    -- Main automation logic here
    
    display notification "Automation completed successfully!" with title "BK25 Automation"
    
on error errorMessage
    display dialog "Automation failed: " & errorMessage buttons {"OK"} default button "OK" with icon stop
end try
```

COMMON PATTERNS:
- Use "tell application" blocks for app interactions
- Use "with timeout" for long-running operations
- Use proper AppleScript record syntax
- Include user confirmations for destructive operations
- Use system events for UI automation when needed

Generate the complete AppleScript now:"""

    def parse_generated_script(self, generated_text: str) -> Dict[str, Any]:
        code_block = re.search(r"```(?:applescript)?\s*([\s\S]*?)```", generated_text, re.I)
        script = (code_block.group(1) if code_block else generated_text).strip()
        script = self._cleanup_script(script)
        documentation = self._extract_documentation(script)
        filename = self._generate_filename(script)
        return {"script": script, "documentation": documentation, "filename": filename}

    def _cleanup_script(self, script: str) -> str:
        script = script.replace("\r\n", "\n").replace("\r", "\n").strip()
        if "osascript" not in script and "Script Editor" not in script:
            filename = self._generate_filename(script)
            script = f"-- Run with: osascript \"{filename}\"\n-- Or open in Script Editor and run\n\n{script}"
        return script

    def _extract_documentation(self, script: str) -> str:
        doc_lines = []
        for line in script.splitlines():
            t = line.strip()
            if t.startswith("--"):
                comment = t[2:].strip()
                if comment and not comment.startswith("Run with:") and not comment.startswith("Or open in"):
                    doc_lines.append(comment)
        return "\n".join(doc_lines).strip() or "AppleScript automation generated by BK25"

    def _generate_filename(self, script: str) -> str:
        m = re.search(r"--\s*Script Name:\s*(.+)", script, re.I)
        if m:
            name = m.group(1).strip().lower()
            cleaned = re.sub(r"[^a-z0-9\s]", "", name)
            return f"{re.sub(r'\s+', '-', cleaned)[:50]}.scpt"
        app = re.search(r"tell application \"([^\"]+)\"", script, re.I)
        if app:
            appname = re.sub(r"\s+", "-", app.group(1).strip().lower())
            return f"{appname}-automation.scpt"
        import datetime as _dt

        ts = _dt.datetime.utcnow().strftime("%Y%m%d%H%M%S")
        return f"bk25-automation-{ts}.scpt"


"""
Bash Script Generator

Generates robust Bash automation scripts for Linux/Unix systems
Focus: System administration, DevOps, server automation
"""

import re
from typing import Dict, Any
from .base import BaseGenerator


class BashGenerator(BaseGenerator):
    """Bash script generator"""
    
    def __init__(self):
        super().__init__("bash", ".sh")
    
    def build_generation_prompt(self, description: str, options: Dict[str, Any] = None) -> str:
        """Build generation prompt for Bash scripts"""
        options = options or {}
        
        prompt = f"""Generate a Bash script for the following automation task:

TASK: {description}

REQUIREMENTS:
- Write production-ready Bash code
- Include proper error handling with set -e and error traps
- Add parameter validation and help documentation
- Use echo for user feedback with appropriate formatting
- Include comments explaining each major step
- Follow Bash best practices and POSIX compliance where possible
- Make the script robust and enterprise-ready
- Include proper exit codes

SCRIPT STRUCTURE:
1. Shebang and script header
2. Error handling setup
3. Parameter validation and help function
4. Main logic with error checking
5. Success/failure reporting
6. Clean exit

EXAMPLE FORMAT:
```bash
#!/bin/bash

# Script Name: Brief description
# Description: Detailed description of the automation task
# Usage: ./script.sh [options]
# Generated by BK25 - Enterprise automation without enterprise complexity

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"

# Error handling
error_exit() {{
    echo "ERROR: $1" >&2
    exit 1
}}

# Cleanup function
cleanup() {{
    echo "Cleaning up..."
    # Add cleanup logic here
}}

# Set trap for cleanup
trap cleanup EXIT

# Help function
show_help() {{
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Description of what this script does.

OPTIONS:
    -h, --help      Show this help message
    -v, --verbose   Enable verbose output

Examples:
    $SCRIPT_NAME --help
    $SCRIPT_NAME --verbose

Generated by BK25 - Enterprise automation without enterprise complexity
EOF
}}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            error_exit "Unknown option: $1"
            ;;
    esac
done

# Main logic
echo "Starting automation..."

# Add your automation logic here

echo "Automation completed successfully!"
```

Generate the complete Bash script now:"""
        
        return prompt
    
    def parse_generated_script(self, generated_text: str) -> Dict[str, Any]:
        """Parse generated script and extract components"""
        # Extract Bash code block
        script = self.extract_code_block(generated_text, "bash")
        
        # Clean up any extra formatting
        script = self.cleanup_script(script)
        
        # Extract documentation from script comments
        documentation = self.extract_documentation(script)
        
        # Generate filename
        filename = self.generate_filename(script)
        
        return {
            "script": script,
            "documentation": documentation,
            "filename": filename
        }
    
    def cleanup_script(self, script: str) -> str:
        """Clean up generated script"""
        # Remove any leading/trailing whitespace
        script = script.strip()
        
        # Ensure proper line endings
        script = self.clean_line_endings(script)
        
        # Add shebang if not present
        if not script.startswith('#!'):
            script = f"#!/bin/bash\n\n{script}"
        
        # Add error handling if not present
        if 'set -e' not in script and 'set -euo pipefail' not in script:
            lines = script.split('\n')
            # Insert after shebang and initial comments
            insert_index = 1
            for i, line in enumerate(lines[1:], 1):
                if not line.strip().startswith('#') and line.strip():
                    insert_index = i
                    break
            
            lines.insert(insert_index, '')
            lines.insert(insert_index + 1, 'set -euo pipefail  # Exit on error, undefined vars, pipe failures')
            script = '\n'.join(lines)
        
        return script
    
    def extract_documentation(self, script: str) -> str:
        """Extract documentation from script"""
        lines = script.split('\n')
        doc_lines = []
        
        for line in lines:
            trimmed_line = line.strip()
            
            # Skip shebang
            if trimmed_line.startswith('#!'):
                continue
            
            # Bash comments start with #
            if trimmed_line.startswith('#'):
                comment = trimmed_line[1:].strip()
                # Skip empty comments, set commands, and the BK25 generated comment
                if (comment and 
                    not comment.startswith('set ') and 
                    'Generated by BK25' not in comment and
                    'Exit on error' not in comment):
                    doc_lines.append(comment)
            
            # Stop collecting documentation after first non-comment, non-empty line
            elif trimmed_line and not trimmed_line.startswith('#'):
                break
        
        return '\n'.join(doc_lines) if doc_lines else "Bash automation script"
    
    def generate_filename(self, script: str) -> str:
        """Generate appropriate filename for Bash script"""
        # Try to extract from script name comments
        lines = script.split('\n')
        for line in lines[:10]:  # Check first 10 lines
            line = line.strip()
            if line.startswith('# Script Name:') or line.startswith('#Script Name:'):
                name_match = re.search(r'# ?Script Name:\s*([^#\n]+)', line, re.IGNORECASE)
                if name_match:
                    name = name_match.group(1).strip()
                    # Clean up name for filename
                    name = re.sub(r'[^\w\s-]', '', name)
                    name = re.sub(r'\s+', '_', name)
                    if name:
                        return f"{name.lower()}.sh"
        
        # Fallback to parent method
        return super().generate_filename(script)
    
    def validate_script_syntax(self, script: str) -> bool:
        """Basic Bash syntax validation"""
        if not super().validate_script_syntax(script):
            return False
        
        # Check for basic Bash patterns
        bash_indicators = [
            r'#!/bin/bash',
            r'#!/bin/sh',
            r'\$\w+',  # Variables
            r'echo\s+',  # Echo commands
            r'if\s*\[',  # If statements
            r'for\s+\w+\s+in',  # For loops
            r'while\s*\[',  # While loops
            r'function\s+\w+',  # Function definitions
        ]
        
        for pattern in bash_indicators:
            if re.search(pattern, script):
                return True
        
        return False
    
    def get_common_patterns(self) -> Dict[str, str]:
        """Get common Bash patterns and templates"""
        return {
            "error_handling": '''
# Error handling
error_exit() {
    echo "ERROR: $1" >&2
    exit 1
}

# Check if command succeeded
if ! command -v some_command &> /dev/null; then
    error_exit "some_command is not installed"
fi
            '''.strip(),
            
            "parameter_validation": '''
# Parameter validation
if [[ $# -eq 0 ]]; then
    echo "Usage: $0 <parameter>"
    exit 1
fi

PARAM="$1"
if [[ -z "$PARAM" ]]; then
    error_exit "Parameter cannot be empty"
fi
            '''.strip(),
            
            "file_operations": '''
# File operations
FILE_PATH="/path/to/file"

if [[ -f "$FILE_PATH" ]]; then
    echo "File exists: $FILE_PATH"
    CONTENT=$(cat "$FILE_PATH")
    echo "Content: $CONTENT"
else
    echo "File not found: $FILE_PATH"
    exit 1
fi
            '''.strip(),
            
            "loops_and_conditionals": '''
# Loop through files
for file in /path/to/files/*; do
    if [[ -f "$file" ]]; then
        echo "Processing: $file"
        # Process file
    fi
done

# Conditional execution
if [[ "$USER" == "root" ]]; then
    echo "Running as root"
else
    echo "Running as regular user"
fi
            '''.strip(),
            
            "system_commands": '''
# System information
HOSTNAME=$(hostname)
UPTIME=$(uptime)
DISK_USAGE=$(df -h)

echo "System: $HOSTNAME"
echo "Uptime: $UPTIME"
echo "Disk Usage:"
echo "$DISK_USAGE"
            '''.strip()
        }
from __future__ import annotations

from typing import Any, Dict
import re
import datetime as _dt


class BashGenerator:
    platform = "bash"
    file_extension = ".sh"

    def build_generation_prompt(self, description: str, options: Dict[str, Any]) -> str:
        return (
            "Generate a Bash script for the following automation task:\n\n"
            + "TASK: "
            + str(description)
            + "\n\n"
            + """
REQUIREMENTS:
- Write production-ready Bash code
- Include proper error handling with set -e and error traps
- Add parameter validation and help documentation
- Use echo for user feedback with appropriate formatting
- Include comments explaining each major step
- Follow Bash best practices and POSIX compliance where possible
- Make the script robust and enterprise-ready
- Include proper exit codes

SCRIPT STRUCTURE:
1. Shebang and script header
2. Error handling setup
3. Parameter validation and help function
4. Main logic with error checking
5. Success/failure reporting
6. Clean exit

EXAMPLE FORMAT:
```bash
#!/bin/bash

# Script Name: Brief description
# Description: Detailed description of the automation task
# Usage: ./script.sh [options]
# Generated by BK25 - Enterprise automation without enterprise complexity

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"

# Error handling
error_exit() {
    echo "ERROR: $1" >&2
    exit 1
}

# Cleanup function
cleanup() {
    echo "Cleaning up..."
}

trap cleanup EXIT

show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Description of what this script does.

OPTIONS:
    -h, --help      Show this help message
    -v, --verbose   Enable verbose output

Generated by BK25 - Enterprise automation without enterprise complexity
EOF
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help) show_help; exit 0;;
        -v|--verbose) VERBOSE=true; shift;;
        *) error_exit "Unknown option: $1";;
    esac
done

main() {
    echo "Starting automation..."
    echo "Automation completed successfully!"
}

main "$@"
```

Generate the complete Bash script now:"""
        )

    def parse_generated_script(self, generated_text: str) -> Dict[str, Any]:
        code_block = re.search(r"```(?:bash|sh)?\s*([\s\S]*?)```", generated_text, re.I)
        script = (code_block.group(1) if code_block else generated_text).strip()
        script = self._cleanup_script(script)
        documentation = self._extract_documentation(script)
        filename = self._generate_filename(script)
        return {"script": script, "documentation": documentation, "filename": filename}

    def _cleanup_script(self, script: str) -> str:
        script = script.strip().replace("\r\n", "\n").replace("\r", "\n")
        if not (script.startswith("#!/bin/bash") or script.startswith("#!/bin/sh")):
            script = f"#!/bin/bash\n\n{script}"
        if "chmod +x" not in script:
            script = f"{script}\n\n# Make executable with: chmod +x {self._generate_filename(script)}"
        return script

    def _extract_documentation(self, script: str) -> str:
        doc_lines = []
        for line in script.splitlines():
            t = line.strip()
            if t.startswith("#") and not t.startswith("#!/"):
                comment = t[1:].strip()
                if comment and not comment.startswith("Make executable with:"):
                    doc_lines.append(comment)
        return "\n".join(doc_lines).strip() or "Bash automation script generated by BK25"

    def _generate_filename(self, script: str) -> str:
        m = re.search(r"#\s*Script Name:\s*(.+)", script, re.I)
        if m:
            name = m.group(1).strip().lower()
            cleaned = re.sub(r"[^a-z0-9\s]", "", name)
            return f"{re.sub(r'\s+', '-', cleaned)[:50]}.sh"
        func = re.search(r"^([a-zA-Z_][a-zA-Z0-9_]*)\(\)", script, re.M)
        if func and func.group(1) != "main":
            return f"{func.group(1)}.sh"
        ts = _dt.datetime.utcnow().strftime("%Y%m%d%H%M%S")
        return f"bk25-automation-{ts}.sh"


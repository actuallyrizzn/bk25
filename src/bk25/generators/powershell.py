from __future__ import annotations

from typing import Any, Dict
import re


class PowerShellGenerator:
    platform = "powershell"
    file_extension = ".ps1"

    def build_generation_prompt(self, description: str, options: Dict[str, Any]) -> str:
        return (
            "Generate a PowerShell script for the following automation task:\n\n"
            + "TASK: "
            + str(description)
            + "\n\n"
            + """

REQUIREMENTS:
- Write production-ready PowerShell code
- Include proper error handling with try/catch blocks
- Add parameter validation and help documentation
- Use Write-Host for user feedback
- Include comments explaining each major step
- Follow PowerShell best practices and naming conventions
- Make the script robust and enterprise-ready

SCRIPT STRUCTURE:
1. Script header with description and parameters
2. Parameter validation
3. Main logic with error handling
4. Success/failure reporting
5. Clean exit

EXAMPLE FORMAT:
```powershell
<#
.SYNOPSIS
    Brief description of what the script does

.DESCRIPTION
    Detailed description of the automation task

.PARAMETER ParameterName
    Description of parameter

.EXAMPLE
    Example of how to run the script

.NOTES
    Generated by BK25 - Enterprise automation without enterprise complexity
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$RequiredParam,
    
    [Parameter(Mandatory=$false)]
    [string]$OptionalParam = "DefaultValue"
)

# Script implementation here
try {
    Write-Host "Starting automation..." -ForegroundColor Green
    
    # Main logic
    
    Write-Host "Automation completed successfully!" -ForegroundColor Green
} catch {
    Write-Error "Automation failed: $($_.Exception.Message)"
    exit 1
}
```

Generate the complete PowerShell script now:"""
        )

    def parse_generated_script(self, generated_text: str) -> Dict[str, Any]:
        code_block = re.search(r"```(?:powershell)?\s*([\s\S]*?)```", generated_text, re.I)
        script = (code_block.group(1) if code_block else generated_text).strip()
        script = self._cleanup_script(script)
        documentation = self._extract_documentation(script)
        filename = self._generate_filename(script)
        return {"script": script, "documentation": documentation, "filename": filename}

    def _cleanup_script(self, script: str) -> str:
        script = script.replace("\r\n", "\n").replace("\r", "\n").strip()
        if "ExecutionPolicy" not in script and "#Requires" not in script:
            script = f"# Run with: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n{script}"
        return script

    def _extract_documentation(self, script: str) -> str:
        doc_lines = []
        in_doc = False
        for line in script.splitlines():
            t = line.strip()
            if t.startswith("<#"):
                in_doc = True
                continue
            if t.startswith("#>"):
                in_doc = False
                continue
            if in_doc:
                doc_lines.append(re.sub(r"^\.", "", t).strip())
            elif t.startswith("#") and not t.startswith("##"):
                doc_lines.append(t[1:].strip())
        return "\n".join(doc_lines).strip() or "PowerShell automation script generated by BK25"

    def _generate_filename(self, script: str) -> str:
        m = re.search(r"\.SYNOPSIS\s*\n\s*(.+)", script, re.I)
        if m:
            synopsis = m.group(1).strip().lower()
            cleaned = re.sub(r"[^a-z0-9\s]", "", synopsis)
            return f"{re.sub(r'\s+', '-', cleaned)[:50]}.ps1"
        import datetime as _dt

        ts = _dt.datetime.utcnow().strftime("%Y%m%d%H%M%S")
        return f"bk25-automation-{ts}.ps1"


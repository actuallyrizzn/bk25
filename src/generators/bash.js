/**
 * Bash Script Generator
 * 
 * Generates robust Bash automation scripts for Linux/Unix systems
 * Focus: System administration, DevOps, server automation
 */

export class BashGenerator {
  constructor() {
    this.platform = 'bash';
    this.fileExtension = '.sh';
  }

  /**
   * Build generation prompt for Bash scripts
   */
  buildGenerationPrompt(description, options = {}) {
    const prompt = `Generate a Bash script for the following automation task:

TASK: ${description}

REQUIREMENTS:
- Write production-ready Bash code
- Include proper error handling with set -e and error traps
- Add parameter validation and help documentation
- Use echo for user feedback with appropriate formatting
- Include comments explaining each major step
- Follow Bash best practices and POSIX compliance where possible
- Make the script robust and enterprise-ready
- Include proper exit codes

SCRIPT STRUCTURE:
1. Shebang and script header
2. Error handling setup
3. Parameter validation and help function
4. Main logic with error checking
5. Success/failure reporting
6. Clean exit

EXAMPLE FORMAT:
\`\`\`bash
#!/bin/bash

# Script Name: Brief description
# Description: Detailed description of the automation task
# Usage: ./script.sh [options]
# Generated by BK25 - Enterprise automation without enterprise complexity

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"

# Error handling
error_exit() {
    echo "ERROR: $1" >&2
    exit 1
}

# Cleanup function
cleanup() {
    echo "Cleaning up..."
    # Add cleanup logic here
}

# Set trap for cleanup
trap cleanup EXIT

# Help function
show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Description of what this script does.

OPTIONS:
    -h, --help      Show this help message
    -v, --verbose   Enable verbose output

Examples:
    $SCRIPT_NAME --help
    $SCRIPT_NAME --verbose

Generated by BK25 - Enterprise automation without enterprise complexity
EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            error_exit "Unknown option: $1"
            ;;
    esac
done

# Main logic
main() {
    echo "Starting automation..."
    
    # Add your automation logic here
    
    echo "Automation completed successfully!"
}

# Run main function
main "$@"
\`\`\`

Generate the complete Bash script now:`;

    return prompt;
  }

  /**
   * Parse generated script and extract components
   */
  parseGeneratedScript(generatedText) {
    // Extract Bash code block
    const codeBlockRegex = /```(?:bash|sh)?\s*([\s\S]*?)```/i;
    const match = generatedText.match(codeBlockRegex);
    
    let script = match ? match[1].trim() : generatedText.trim();
    
    // Clean up any extra formatting
    script = this.cleanupScript(script);
    
    // Extract documentation from script comments
    const documentation = this.extractDocumentation(script);
    
    // Generate filename
    const filename = this.generateFilename(script);
    
    return {
      script: script,
      documentation: documentation,
      filename: filename
    };
  }

  /**
   * Clean up generated script
   */
  cleanupScript(script) {
    // Remove any leading/trailing whitespace
    script = script.trim();
    
    // Ensure proper line endings
    script = script.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    
    // Ensure shebang is present
    if (!script.startsWith('#!/bin/bash') && !script.startsWith('#!/bin/sh')) {
      script = `#!/bin/bash\n\n${script}`;
    }
    
    // Add execution instructions if not present
    if (!script.includes('chmod +x')) {
      const filename = this.generateFilename(script);
      script = `${script}\n\n# Make executable with: chmod +x ${filename}`;
    }
    
    return script;
  }

  /**
   * Extract documentation from script
   */
  extractDocumentation(script) {
    const lines = script.split('\n');
    const docLines = [];
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      if (trimmedLine.startsWith('#') && !trimmedLine.startsWith('#!/')) {
        const comment = trimmedLine.substring(1).trim();
        if (comment && !comment.startsWith('Make executable with:')) {
          docLines.push(comment);
        }
      }
    }
    
    return docLines.join('\n').trim() || 'Bash automation script generated by BK25';
  }

  /**
   * Generate appropriate filename
   */
  generateFilename(script) {
    // Try to extract a meaningful name from script comments
    const nameMatch = script.match(/#\s*Script Name:\s*(.+)/i);
    if (nameMatch) {
      const name = nameMatch[1].trim();
      const filename = name
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);
      return `${filename}.sh`;
    }
    
    // Look for function names or main operations
    const functionMatch = script.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\(\)/m);
    if (functionMatch && functionMatch[1] !== 'main') {
      return `${functionMatch[1]}.sh`;
    }
    
    // Fallback to generic name with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
    return `bk25-automation-${timestamp}.sh`;
  }

  /**
   * Get common Bash script templates
   */
  getTemplates() {
    return {
      'file-processing': {
        description: 'Process files in a directory',
        template: '#!/bin/bash\n\nset -euo pipefail\n\n# File Processing Script\n# Generated by BK25\n\nSOURCE_DIR="${1:-./}"\nFILE_PATTERN="${2:-*}"\n\nerror_exit() {\n    echo "ERROR: $1" >&2\n    exit 1\n}\n\nmain() {\n    echo "Processing files in: $SOURCE_DIR"\n    echo "Pattern: $FILE_PATTERN"\n    \n    if [[ ! -d "$SOURCE_DIR" ]]; then\n        error_exit "Directory does not exist: $SOURCE_DIR"\n    fi\n    \n    local count=0\n    for file in "$SOURCE_DIR"/$FILE_PATTERN; do\n        if [[ -f "$file" ]]; then\n            echo "Processing: $(basename "$file")"\n            # Add your file processing logic here\n            ((count++))\n        fi\n    done\n    \n    echo "Processed $count files successfully!"\n}\n\nmain "$@"'
      },
      
      'system-monitoring': {
        description: 'Monitor system resources',
        template: '#!/bin/bash\n\nset -euo pipefail\n\n# System Monitoring Script\n# Generated by BK25\n\nCPU_THRESHOLD="${1:-80}"\nMEMORY_THRESHOLD="${2:-80}"\n\ncheck_cpu() {\n    local cpu_usage\n    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk \'{print $2}\' | awk -F\'%\' \'{print $1}\')\n    echo "CPU Usage: ${cpu_usage}%"\n    \n    if (( $(echo "$cpu_usage > $CPU_THRESHOLD" | bc -l) )); then\n        echo "WARNING: CPU usage above threshold!"\n        return 1\n    fi\n    return 0\n}\n\ncheck_memory() {\n    local memory_usage\n    memory_usage=$(free | grep Mem | awk \'{printf("%.1f", $3/$2 * 100.0)}\')\n    echo "Memory Usage: ${memory_usage}%"\n    \n    if (( $(echo "$memory_usage > $MEMORY_THRESHOLD" | bc -l) )); then\n        echo "WARNING: Memory usage above threshold!"\n        return 1\n    fi\n    return 0\n}\n\nmain() {\n    echo "System Resource Monitor"\n    echo "======================"\n    \n    check_cpu\n    check_memory\n    \n    echo "System monitoring completed!"\n}\n\nmain "$@"'
      },
      
      'backup-automation': {
        description: 'Automated backup script',
        template: '#!/bin/bash\n\nset -euo pipefail\n\n# Backup Automation Script\n# Generated by BK25\n\nSOURCE_DIR="${1:-./}"\nBACKUP_DIR="${2:-./backups}"\nTIMESTAMP=$(date +"%Y%m%d_%H%M%S")\n\nerror_exit() {\n    echo "ERROR: $1" >&2\n    exit 1\n}\n\ncreate_backup() {\n    local source="$1"\n    local destination="$2"\n    \n    echo "Creating backup from $source to $destination"\n    \n    if [[ ! -d "$source" ]]; then\n        error_exit "Source directory does not exist: $source"\n    fi\n    \n    mkdir -p "$destination"\n    \n    tar -czf "$destination/backup_$TIMESTAMP.tar.gz" -C "$source" .\n    \n    echo "Backup created: $destination/backup_$TIMESTAMP.tar.gz"\n}\n\ncleanup_old_backups() {\n    local backup_dir="$1"\n    local keep_days="${2:-7}"\n    \n    echo "Cleaning up backups older than $keep_days days"\n    \n    find "$backup_dir" -name "backup_*.tar.gz" -mtime +$keep_days -exec rm {} \\;\n    \n    echo "Cleanup completed"\n}\n\nmain() {\n    echo "Starting backup automation..."\n    \n    create_backup "$SOURCE_DIR" "$BACKUP_DIR"\n    cleanup_old_backups "$BACKUP_DIR" 7\n    \n    echo "Backup automation completed successfully!"\n}\n\nmain "$@"'
      },
      
      'log-analysis': {
        description: 'Analyze log files',
        template: '#!/bin/bash\n\nset -euo pipefail\n\n# Log Analysis Script\n# Generated by BK25\n\nLOG_FILE="${1:-/var/log/syslog}"\nOUTPUT_FILE="${2:-log_analysis_$(date +%Y%m%d).txt}"\n\nerror_exit() {\n    echo "ERROR: $1" >&2\n    exit 1\n}\n\nanalyze_logs() {\n    local log_file="$1"\n    local output_file="$2"\n    \n    if [[ ! -f "$log_file" ]]; then\n        error_exit "Log file does not exist: $log_file"\n    fi\n    \n    echo "Analyzing log file: $log_file"\n    echo "Output file: $output_file"\n    \n    {\n        echo "Log Analysis Report - $(date)"\n        echo "================================"\n        echo\n        echo "Total lines: $(wc -l < "$log_file")"\n        echo "File size: $(du -h "$log_file" | cut -f1)"\n        echo\n        echo "Top 10 most frequent log entries:"\n        awk \'{print $5, $6, $7, $8, $9, $10}\' "$log_file" | sort | uniq -c | sort -nr | head -10\n        echo\n        echo "Error entries:"\n        grep -i error "$log_file" | tail -20\n    } > "$output_file"\n    \n    echo "Analysis completed. Results saved to: $output_file"\n}\n\nmain() {\n    echo "Starting log analysis..."\n    \n    analyze_logs "$LOG_FILE" "$OUTPUT_FILE"\n    \n    echo "Log analysis completed successfully!"\n}\n\nmain "$@"'
      }
    };
  }

  /**
   * Validate generated Bash script
   */
  validateScript(script) {
    const issues = [];
    
    // Check for shebang
    if (!script.startsWith('#!/bin/bash') && !script.startsWith('#!/bin/sh')) {
      issues.push('Script missing shebang line');
    }
    
    // Check for error handling
    if (!script.includes('set -e') && !script.includes('error_exit')) {
      issues.push('Script lacks proper error handling');
    }
    
    // Check for user feedback
    if (!script.includes('echo') && !script.includes('printf')) {
      issues.push('Script provides no user feedback');
    }
    
    // Check for proper variable usage
    if (script.includes('$1') && !script.includes('${1') && !script.includes('"$1"')) {
      issues.push('Script may have unquoted variable usage');
    }
    
    return {
      isValid: issues.length === 0,
      issues: issues
    };
  }

  /**
   * Get common Bash utilities and commands
   */
  getCommonCommands() {
    return {
      'file-operations': [
        'find', 'grep', 'sed', 'awk', 'sort', 'uniq', 'cut', 'tr',
        'head', 'tail', 'wc', 'du', 'df', 'ls', 'cp', 'mv', 'rm'
      ],
      'system-info': [
        'ps', 'top', 'htop', 'free', 'df', 'lsof', 'netstat', 'ss',
        'uname', 'whoami', 'id', 'groups', 'uptime', 'date'
      ],
      'network': [
        'curl', 'wget', 'ping', 'nslookup', 'dig', 'ssh', 'scp', 'rsync'
      ],
      'archive': [
        'tar', 'gzip', 'gunzip', 'zip', 'unzip', '7z'
      ],
      'text-processing': [
        'cat', 'less', 'more', 'vim', 'nano', 'diff', 'patch'
      ]
    };
  }
}

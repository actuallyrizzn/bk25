/**
 * PowerShell Script Generator
 * 
 * Generates robust, production-ready PowerShell automation scripts
 * Focus: Windows enterprise environments, Office 365, Active Directory
 */

export class PowerShellGenerator {
  constructor() {
    this.platform = 'powershell';
    this.fileExtension = '.ps1';
  }

  /**
   * Build generation prompt for PowerShell scripts
   */
  buildGenerationPrompt(description, options = {}) {
    const prompt = `Generate a PowerShell script for the following automation task:

TASK: ${description}

REQUIREMENTS:
- Write production-ready PowerShell code
- Include proper error handling with try/catch blocks
- Add parameter validation and help documentation
- Use Write-Host for user feedback
- Include comments explaining each major step
- Follow PowerShell best practices and naming conventions
- Make the script robust and enterprise-ready

SCRIPT STRUCTURE:
1. Script header with description and parameters
2. Parameter validation
3. Main logic with error handling
4. Success/failure reporting
5. Clean exit

EXAMPLE FORMAT:
\`\`\`powershell
<#
.SYNOPSIS
    Brief description of what the script does

.DESCRIPTION
    Detailed description of the automation task

.PARAMETER ParameterName
    Description of parameter

.EXAMPLE
    Example of how to run the script

.NOTES
    Generated by BK25 - Enterprise automation without enterprise complexity
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$RequiredParam,
    
    [Parameter(Mandatory=$false)]
    [string]$OptionalParam = "DefaultValue"
)

# Script implementation here
try {
    Write-Host "Starting automation..." -ForegroundColor Green
    
    # Main logic
    
    Write-Host "Automation completed successfully!" -ForegroundColor Green
} catch {
    Write-Error "Automation failed: $($_.Exception.Message)"
    exit 1
}
\`\`\`

Generate the complete PowerShell script now:`;

    return prompt;
  }

  /**
   * Parse generated script and extract components
   */
  parseGeneratedScript(generatedText) {
    // Extract PowerShell code block
    const codeBlockRegex = /```(?:powershell)?\s*([\s\S]*?)```/i;
    const match = generatedText.match(codeBlockRegex);
    
    let script = match ? match[1].trim() : generatedText.trim();
    
    // Clean up any extra formatting
    script = this.cleanupScript(script);
    
    // Extract documentation from script comments
    const documentation = this.extractDocumentation(script);
    
    // Generate filename
    const filename = this.generateFilename(script);
    
    return {
      script: script,
      documentation: documentation,
      filename: filename
    };
  }

  /**
   * Clean up generated script
   */
  cleanupScript(script) {
    // Remove any leading/trailing whitespace
    script = script.trim();
    
    // Ensure proper line endings
    script = script.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    
    // Add execution policy comment if not present
    if (!script.includes('ExecutionPolicy') && !script.includes('#Requires')) {
      script = `# Run with: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n${script}`;
    }
    
    return script;
  }

  /**
   * Extract documentation from script
   */
  extractDocumentation(script) {
    const lines = script.split('\n');
    const docLines = [];
    let inDocBlock = false;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      if (trimmedLine.startsWith('<#')) {
        inDocBlock = true;
        continue;
      }
      
      if (trimmedLine.startsWith('#>')) {
        inDocBlock = false;
        continue;
      }
      
      if (inDocBlock) {
        docLines.push(trimmedLine.replace(/^\./, '').trim());
      } else if (trimmedLine.startsWith('#') && !trimmedLine.startsWith('##')) {
        docLines.push(trimmedLine.substring(1).trim());
      }
    }
    
    return docLines.join('\n').trim() || 'PowerShell automation script generated by BK25';
  }

  /**
   * Generate appropriate filename
   */
  generateFilename(script) {
    // Try to extract a meaningful name from the script
    const synopsisMatch = script.match(/\.SYNOPSIS\s*\n\s*(.+)/i);
    if (synopsisMatch) {
      const synopsis = synopsisMatch[1].trim();
      const filename = synopsis
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);
      return `${filename}.ps1`;
    }
    
    // Fallback to generic name with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
    return `bk25-automation-${timestamp}.ps1`;
  }

  /**
   * Get common PowerShell templates
   */
  getTemplates() {
    return {
      'file-processing': {
        description: 'Process files in a directory',
        template: `
param(
    [Parameter(Mandatory=$true)]
    [string]$SourcePath,
    
    [Parameter(Mandatory=$false)]
    [string]$FilePattern = "*.*"
)

try {
    $files = Get-ChildItem -Path $SourcePath -Filter $FilePattern
    Write-Host "Found $($files.Count) files to process" -ForegroundColor Green
    
    foreach ($file in $files) {
        Write-Host "Processing: $($file.Name)" -ForegroundColor Yellow
        # Add your file processing logic here
    }
    
    Write-Host "File processing completed!" -ForegroundColor Green
} catch {
    Write-Error "File processing failed: $($_.Exception.Message)"
    exit 1
}`
      },
      
      'email-automation': {
        description: 'Send automated emails',
        template: `
param(
    [Parameter(Mandatory=$true)]
    [string[]]$Recipients,
    
    [Parameter(Mandatory=$true)]
    [string]$Subject,
    
    [Parameter(Mandatory=$true)]
    [string]$Body,
    
    [Parameter(Mandatory=$false)]
    [string]$SmtpServer = "smtp.office365.com"
)

try {
    foreach ($recipient in $Recipients) {
        Send-MailMessage -To $recipient -Subject $Subject -Body $Body -SmtpServer $SmtpServer
        Write-Host "Email sent to: $recipient" -ForegroundColor Green
    }
    
    Write-Host "All emails sent successfully!" -ForegroundColor Green
} catch {
    Write-Error "Email sending failed: $($_.Exception.Message)"
    exit 1
}`
      },
      
      'system-monitoring': {
        description: 'Monitor system resources',
        template: `
param(
    [Parameter(Mandatory=$false)]
    [int]$CpuThreshold = 80,
    
    [Parameter(Mandatory=$false)]
    [int]$MemoryThreshold = 80
)

try {
    $cpu = Get-Counter "\\Processor(_Total)\\% Processor Time" | Select-Object -ExpandProperty CounterSamples | Select-Object -ExpandProperty CookedValue
    $memory = Get-Counter "\\Memory\\% Committed Bytes In Use" | Select-Object -ExpandProperty CounterSamples | Select-Object -ExpandProperty CookedValue
    
    Write-Host "CPU Usage: $([math]::Round($cpu, 2))%" -ForegroundColor $(if($cpu -gt $CpuThreshold) {"Red"} else {"Green"})
    Write-Host "Memory Usage: $([math]::Round($memory, 2))%" -ForegroundColor $(if($memory -gt $MemoryThreshold) {"Red"} else {"Green"})
    
    if ($cpu -gt $CpuThreshold -or $memory -gt $MemoryThreshold) {
        Write-Warning "System resources are above threshold!"
        # Add alerting logic here
    }
    
} catch {
    Write-Error "System monitoring failed: $($_.Exception.Message)"
    exit 1
}`
      }
    };
  }

  /**
   * Validate generated PowerShell script
   */
  validateScript(script) {
    const issues = [];
    
    // Check for basic PowerShell syntax
    if (!script.includes('param(') && script.includes('$')) {
      issues.push('Script uses variables but has no parameter block');
    }
    
    // Check for error handling
    if (!script.includes('try') && !script.includes('catch')) {
      issues.push('Script lacks error handling');
    }
    
    // Check for user feedback
    if (!script.includes('Write-Host') && !script.includes('Write-Output')) {
      issues.push('Script provides no user feedback');
    }
    
    return {
      isValid: issues.length === 0,
      issues: issues
    };
  }
}

"""
PowerShell Script Generator

Generates robust, production-ready PowerShell automation scripts.
Focus: Windows enterprise environments, Office 365, Active Directory
"""

import re
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from ..logging_config import get_logger

logger = get_logger("powershell_generator")

@dataclass
class ScriptValidation:
    """Script validation results"""
    is_valid: bool
    issues: List[str]
    suggestions: List[str]

class PowerShellGenerator:
    """Generates PowerShell automation scripts"""
    
    def __init__(self):
        self.platform = 'powershell'
        self.file_extension = '.ps1'
        self.logger = get_logger("powershell_generator")
    
    def build_generation_prompt(self, description: str, options: Optional[Dict[str, Any]] = None) -> str:
        """Build generation prompt for PowerShell scripts"""
        options = options or {}
        
        prompt = f"""Generate a PowerShell script for the following automation task:

TASK: {description}

REQUIREMENTS:
- Write production-ready PowerShell code
- Include proper error handling with try/catch blocks
- Add parameter validation and help documentation
- Use Write-Host for user feedback
- Include comments explaining each major step
- Follow PowerShell best practices and naming conventions
- Make the script robust and enterprise-ready

SCRIPT STRUCTURE:
1. Script header with description and parameters
2. Parameter validation
3. Main logic with error handling
4. Success/failure reporting
5. Clean exit

EXAMPLE FORMAT:
```powershell
<#
.SYNOPSIS
    Brief description of what the script does

.DESCRIPTION
    Detailed description of the automation task

.PARAMETER ParameterName
    Description of parameter

.EXAMPLE
    Example of how to run the script

.NOTES
    Generated by BK25 - Enterprise automation without enterprise complexity
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$RequiredParam,
    
    [Parameter(Mandatory=$false)]
    [string]$OptionalParam = "DefaultValue"
)

# Script implementation here
try {{
    Write-Host "Starting automation..." -ForegroundColor Green
    
    # Main logic
    
    Write-Host "Automation completed successfully!" -ForegroundColor Green
}} catch {{
    Write-Error "Automation failed: $($_.Exception.Message)"
    exit 1
}}
```

Generate the complete PowerShell script now:"""
        
        return prompt
    
    def parse_generated_script(self, generated_text: str) -> Dict[str, str]:
        """Parse generated script and extract components"""
        # Extract PowerShell code block
        code_block_regex = r'```(?:powershell)?\s*([\s\S]*?)```'
        match = re.search(code_block_regex, generated_text, re.IGNORECASE)
        
        script = match.group(1).strip() if match else generated_text.strip()
        
        # Clean up any extra formatting
        script = self.cleanup_script(script)
        
        # Extract documentation from script comments
        documentation = self.extract_documentation(script)
        
        # Generate filename
        filename = self.generate_filename(script)
        
        return {
            'script': script,
            'documentation': documentation,
            'filename': filename
        }
    
    def cleanup_script(self, script: str) -> str:
        """Clean up generated script"""
        # Remove any leading/trailing whitespace
        script = script.strip()
        
        # Ensure proper line endings
        script = script.replace('\r\n', '\n').replace('\r', '\n')
        
        # Add execution policy comment if not present
        if not re.search(r'ExecutionPolicy|#Requires', script, re.IGNORECASE):
            script = f"# Run with: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n{script}"
        
        return script
    
    def extract_documentation(self, script: str) -> str:
        """Extract documentation from script"""
        lines = script.split('\n')
        doc_lines = []
        in_doc_block = False
        
        for line in lines:
            trimmed_line = line.strip()
            
            if trimmed_line.startswith('<#'):
                in_doc_block = True
                continue
            
            if trimmed_line.startswith('#>'):
                in_doc_block = False
                continue
            
            if in_doc_block:
                doc_lines.append(trimmed_line.replace('.', '', 1).strip())
            elif trimmed_line.startswith('#') and not trimmed_line.startswith('##'):
                doc_lines.append(trimmed_line[1:].strip())
        
        return '\n'.join(doc_lines).strip() or 'PowerShell automation script generated by BK25'
    
    def generate_filename(self, script: str) -> str:
        """Generate appropriate filename"""
        # Try to extract a meaningful name from the script
        synopsis_match = re.search(r'\.SYNOPSIS\s*\n\s*(.+)', script, re.IGNORECASE)
        if synopsis_match:
            synopsis = synopsis_match.group(1).strip()
            filename = re.sub(r'[^a-z0-9\s]', '', synopsis.lower())
            filename = re.sub(r'\s+', '-', filename)[:50]
            return f"{filename}.ps1"
        
        # Fallback to generic name with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"bk25-automation-{timestamp}.ps1"
    
    def get_templates(self) -> Dict[str, Dict[str, str]]:
        """Get common PowerShell templates"""
        return {
            'file-processing': {
                'description': 'Process files in a directory',
                'template': '''param(
    [Parameter(Mandatory=$true)]
    [string]$SourcePath,
    
    [Parameter(Mandatory=$false)]
    [string]$FilePattern = "*.*"
)

try {
    $files = Get-ChildItem -Path $SourcePath -Filter $FilePattern
    Write-Host "Found $($files.Count) files to process" -ForegroundColor Green
    
    foreach ($file in $files) {
        Write-Host "Processing: $($file.Name)" -ForegroundColor Yellow
        # Add your file processing logic here
    }
    
    Write-Host "File processing completed!" -ForegroundColor Green
} catch {
    Write-Error "File processing failed: $($_.Exception.Message)"
    exit 1
}'''
            },
            
            'email-automation': {
                'description': 'Send automated emails',
                'template': '''param(
    [Parameter(Mandatory=$true)]
    [string[]]$Recipients,
    
    [Parameter(Mandatory=$true)]
    [string]$Subject,
    
    [Parameter(Mandatory=$true)]
    [string]$Body,
    
    [Parameter(Mandatory=$false)]
    [string]$SmtpServer = "smtp.office365.com"
)

try {
    foreach ($recipient in $Recipients) {
        Send-MailMessage -To $recipient -Subject $Subject -Body $Body -SmtpServer $SmtpServer
        Write-Host "Email sent to: $recipient" -ForegroundColor Green
    }
    
    Write-Host "All emails sent successfully!" -ForegroundColor Green
} catch {
    Write-Error "Email sending failed: $($_.Exception.Message)"
    exit 1
}'''
            },
            
            'system-monitoring': {
                'description': 'Monitor system resources',
                'template': '''param(
    [Parameter(Mandatory=$false)]
    [int]$CpuThreshold = 80,
    
    [Parameter(Mandatory=$false)]
    [int]$MemoryThreshold = 80
)

try {
    $cpu = Get-Counter "\\Processor(_Total)\\% Processor Time" | Select-Object -ExpandProperty CounterSamples | Select-Object -ExpandProperty CookedValue
    $memory = Get-Counter "\\Memory\\% Committed Bytes In Use" | Select-Object -ExpandProperty CounterSamples | Select-Object -ExpandProperty CookedValue
    
    Write-Host "CPU Usage: $([math]::Round($cpu, 2))%" -ForegroundColor $(if($cpu -gt $CpuThreshold) {"Red"} else {"Green"})
    Write-Host "Memory Usage: $([math]::Round($memory, 2))%" -ForegroundColor $(if($memory -gt $MemoryThreshold) {"Red"} else {"Green"})
    
    if ($cpu -gt $CpuThreshold -or $memory -gt $MemoryThreshold) {
        Write-Warning "System resources are above threshold!"
        # Add alerting logic here
    }
    
} catch {
    Write-Error "System monitoring failed: $($_.Exception.Message)"
    exit 1
}'''
            },
            
            'active-directory': {
                'description': 'Active Directory operations',
                'template': '''param(
    [Parameter(Mandatory=$true)]
    [string]$SearchBase,
    
    [Parameter(Mandatory=$false)]
    [string]$Filter = "*"
)

try {
    # Import Active Directory module
    Import-Module ActiveDirectory
    
    Write-Host "Searching AD objects in: $SearchBase" -ForegroundColor Green
    
    $adObjects = Get-ADObject -SearchBase $SearchBase -Filter $Filter
    
    Write-Host "Found $($adObjects.Count) AD objects" -ForegroundColor Green
    
    foreach ($obj in $adObjects) {
        Write-Host "Object: $($obj.Name) ($($obj.ObjectClass))" -ForegroundColor Yellow
        # Add your AD processing logic here
    }
    
    Write-Host "AD operation completed successfully!" -ForegroundColor Green
    
} catch {
    Write-Error "AD operation failed: $($_.Exception.Message)"
    exit 1
}'''
            }
        }
    
    def validate_script(self, script: str) -> ScriptValidation:
        """Validate generated PowerShell script"""
        issues = []
        suggestions = []
        
        # Check for basic PowerShell syntax
        if re.search(r'\$[a-zA-Z]', script) and not re.search(r'param\(', script):
            issues.append('Script uses variables but has no parameter block')
            suggestions.append('Add a param() block to define script parameters')
        
        # Check for error handling
        if not re.search(r'try|catch', script, re.IGNORECASE):
            issues.append('Script lacks error handling')
            suggestions.append('Wrap main logic in try-catch blocks')
        
        # Check for user feedback
        if not re.search(r'Write-Host|Write-Output|Write-Verbose', script, re.IGNORECASE):
            issues.append('Script provides no user feedback')
            suggestions.append('Add Write-Host statements for user feedback')
        
        # Check for proper parameter validation
        if re.search(r'param\(', script) and not re.search(r'Mandatory', script):
            suggestions.append('Consider adding Mandatory=$true for required parameters')
        
        # Check for execution policy handling
        if not re.search(r'ExecutionPolicy|#Requires', script, re.IGNORECASE):
            suggestions.append('Consider adding execution policy guidance in comments')
        
        return ScriptValidation(
            is_valid=len(issues) == 0,
            issues=issues,
            suggestions=suggestions
        )
    
    def get_common_cmdlets(self) -> Dict[str, List[str]]:
        """Get common PowerShell cmdlets by category"""
        return {
            'file-system': [
                'Get-ChildItem', 'Get-Content', 'Set-Content', 'Copy-Item', 'Move-Item',
                'Remove-Item', 'New-Item', 'Test-Path', 'Get-Location', 'Set-Location'
            ],
            'system-management': [
                'Get-Process', 'Get-Service', 'Start-Service', 'Stop-Service',
                'Get-ComputerInfo', 'Get-WmiObject', 'Get-Counter', 'Restart-Computer'
            ],
            'active-directory': [
                'Get-ADUser', 'Get-ADGroup', 'Get-ADComputer', 'New-ADUser',
                'Add-ADGroupMember', 'Remove-ADGroupMember', 'Set-ADUser'
            ],
            'office-365': [
                'Connect-ExchangeOnline', 'Get-Mailbox', 'Get-User', 'Set-Mailbox',
                'New-Mailbox', 'Remove-Mailbox', 'Get-DistributionGroup'
            ],
            'azure': [
                'Connect-AzAccount', 'Get-AzResource', 'New-AzResourceGroup',
                'Get-AzVM', 'Start-AzVM', 'Stop-AzVM', 'Get-AzStorageAccount'
            ],
            'networking': [
                'Test-NetConnection', 'Get-NetAdapter', 'Get-NetIPAddress',
                'Test-WSMan', 'Invoke-WebRequest', 'Invoke-RestMethod'
            ]
        }
    
    def get_execution_policies(self) -> List[str]:
        """Get available PowerShell execution policies"""
        return [
            'Restricted',
            'AllSigned',
            'RemoteSigned',
            'Unrestricted',
            'Bypass',
            'Undefined'
        ]

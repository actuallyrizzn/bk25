"""
Bash Script Generator

Generates robust, production-ready Bash automation scripts.
Focus: Linux/Unix automation, system administration, DevOps tasks
"""

import re
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from ..logging_config import get_logger

logger = get_logger("bash_generator")

@dataclass
class ScriptValidation:
    """Script validation results"""
    is_valid: bool
    issues: List[str]
    suggestions: List[str]

class BashGenerator:
    """Generates Bash automation scripts"""
    
    def __init__(self):
        self.platform = 'bash'
        self.file_extension = '.sh'
        self.logger = get_logger("bash_generator")
    
    def build_generation_prompt(self, description: str, options: Optional[Dict[str, Any]] = None) -> str:
        """Build generation prompt for Bash scripts"""
        options = options or {}
        
        prompt = f"""Generate a Bash script for the following automation task:

TASK: {description}

REQUIREMENTS:
- Write production-ready Bash code
- Include proper error handling with set -e and trap
- Add parameter validation and help documentation
- Use echo for user feedback and logging
- Include comments explaining each major step
- Follow Bash best practices and naming conventions
- Make the script robust and portable
- Handle errors gracefully and exit cleanly

SCRIPT STRUCTURE:
1. Shebang and script header
2. Parameter parsing and validation
3. Error handling setup
4. Main logic with progress feedback
5. Success/failure reporting
6. Clean exit

EXAMPLE FORMAT:
```bash
#!/bin/bash

# Bash: Brief description of what the script does
# Generated by BK25 - Enterprise automation without enterprise complexity
# Date: {datetime.now().strftime('%Y-%m-%d')}

set -e  # Exit on any error
set -u  # Exit on undefined variables

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

# Error handling
trap 'echo -e "${{RED}}Error occurred. Cleaning up...${{NC}}"; exit 1' ERR

# Function to print colored output
print_status() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

print_error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

# Help function
show_help() {{
    echo "Usage: $0 [OPTIONS]"
    echo "Description: Brief description"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -v, --verbose  Enable verbose output"
    echo ""
    echo "Example: $0 --verbose"
    exit 0
}}

# Parse command line arguments
VERBOSE=false
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            ;;
    esac
done

# Main script logic
main() {{
    print_status "Starting automation..."
    
    # Add your main logic here
    
    print_status "Automation completed successfully!"
}}

# Run main function
main "$@"
```

Generate the complete Bash script now:"""
        
        return prompt
    
    def parse_generated_script(self, generated_text: str) -> Dict[str, str]:
        """Parse generated script and extract components"""
        # Extract Bash code block
        code_block_regex = r'```(?:bash)?\s*([\s\S]*?)```'
        match = re.search(code_block_regex, generated_text, re.IGNORECASE)
        
        script = match.group(1).strip() if match else generated_text.strip()
        
        # Clean up any extra formatting
        script = self.cleanup_script(script)
        
        # Extract documentation from script comments
        documentation = self.extract_documentation(script)
        
        # Generate filename
        filename = self.generate_filename(script)
        
        return {
            'script': script,
            'documentation': documentation,
            'filename': filename
        }
    
    def cleanup_script(self, script: str) -> str:
        """Clean up generated script"""
        # Remove any leading/trailing whitespace
        script = script.strip()
        
        # Ensure proper line endings
        script = script.replace('\r\n', '\n').replace('\r', '\n')
        
        # Add shebang if not present
        if not script.startswith('#!/bin/bash'):
            script = "#!/bin/bash\n\n" + script
        
        # Ensure executable permissions comment
        if not re.search(r'chmod|executable', script, re.IGNORECASE):
            script += "\n\n# Make script executable: chmod +x " + self.generate_filename(script)
        
        return script
    
    def extract_documentation(self, script: str) -> str:
        """Extract documentation from script"""
        lines = script.split('\n')
        doc_lines = []
        
        for line in lines:
            trimmed_line = line.strip()
            
            # Extract comments (lines starting with #)
            if trimmed_line.startswith('#') and not trimmed_line.startswith('##'):
                comment = trimmed_line[1:].strip()
                if comment and not comment.startswith('Generated by') and not comment.startswith('chmod'):
                    doc_lines.append(comment)
        
        return '\n'.join(doc_lines).strip() or 'Bash automation script generated by BK25'
    
    def generate_filename(self, script: str) -> str:
        """Generate appropriate filename"""
        # Try to extract a meaningful name from the script
        # Look for description in comments
        desc_match = re.search(r'#\s*Bash:\s*(.+)', script, re.IGNORECASE)
        if desc_match:
            description = desc_match.group(1).strip()
            filename = re.sub(r'[^a-z0-9\s]', '', description.lower())
            filename = re.sub(r'\s+', '-', filename)[:50]
            return f"{filename}.sh"
        
        # Fallback to generic name with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"bk25-automation-{timestamp}.sh"
    
    def get_templates(self) -> Dict[str, Dict[str, str]]:
        """Get common Bash templates"""
        return {
            'file-processing': {
                'description': 'Process files in directory',
                'template': '''#!/bin/bash

# Bash: Process files in directory
# Generated by BK25 - Enterprise automation without enterprise complexity

set -e
set -u

# Colors for output
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m'

# Error handling
trap 'echo -e "${{RED}}Error occurred. Cleaning up...${{NC}}"; exit 1' ERR

print_status() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

show_help() {{
    echo "Usage: $0 <source_directory> [file_pattern]"
    echo "Description: Process files in the specified directory"
    echo ""
    echo "Arguments:"
    echo "  source_directory  Directory containing files to process"
    echo "  file_pattern      Optional file pattern (default: *)"
    echo ""
    echo "Example: $0 /path/to/files "*.txt""
    exit 0
}}

# Parse arguments
if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
fi

SOURCE_DIR="$1"
FILE_PATTERN="${{2:-*}}"

# Validate source directory
if [[ ! -d "$SOURCE_DIR" ]]; then
    echo -e "${{RED}}[ERROR]${{NC}} Source directory does not exist: $SOURCE_DIR"
    exit 1
fi

print_status "Processing files in: $SOURCE_DIR"
print_status "File pattern: $FILE_PATTERN"

# Count files
FILE_COUNT=$(find "$SOURCE_DIR" -maxdepth 1 -name "$FILE_PATTERN" -type f | wc -l)
print_status "Found $FILE_COUNT files to process"

# Process files
find "$SOURCE_DIR" -maxdepth 1 -name "$FILE_PATTERN" -type f | while read -r file; do
    filename=$(basename "$file")
    print_status "Processing: $filename"
    
    # Add your file processing logic here
    # Example: echo "Processing $filename"
    
done

print_status "File processing completed successfully!"'''
            },
            
            'system-monitoring': {
                'description': 'Monitor system resources',
                'template': '''#!/bin/bash

# Bash: Monitor system resources
# Generated by BK25 - Enterprise automation without enterprise complexity

set -e
set -u

# Colors for output
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m'

# Error handling
trap 'echo -e "${{RED}}Error occurred. Cleaning up...${{NC}}"; exit 1' ERR

print_status() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

print_error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

show_help() {{
    echo "Usage: $0 [OPTIONS]"
    echo "Description: Monitor system resources"
    echo ""
    echo "Options:"
    echo "  -h, --help           Show this help message"
    echo "  -c, --cpu-threshold  CPU threshold percentage (default: 80)"
    echo "  -m, --mem-threshold  Memory threshold percentage (default: 80)"
    echo ""
    echo "Example: $0 --cpu-threshold 90 --mem-threshold 85"
    exit 0
}}

# Default thresholds
CPU_THRESHOLD=80
MEM_THRESHOLD=80

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -c|--cpu-threshold)
            CPU_THRESHOLD="$2"
            shift 2
            ;;
        -m|--mem-threshold)
            MEM_THRESHOLD="$2"
            shift 2
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            ;;
    esac
done

print_status "Starting system monitoring..."
print_status "CPU threshold: $CPU_THRESHOLD%"
print_status "Memory threshold: $MEM_THRESHOLD%"

# Get CPU usage
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{{print $2}}' | cut -d'%' -f1)
CPU_USAGE=$(printf "%.0f" "$CPU_USAGE")

# Get memory usage
MEM_USAGE=$(free | grep Mem | awk '{{printf "%.0f", $3/$2 * 100.0}}')

print_status "Current CPU usage: $CPU_USAGE%"
print_status "Current memory usage: $MEM_USAGE%"

# Check thresholds
if [[ $CPU_USAGE -gt $CPU_THRESHOLD ]]; then
    print_warning "CPU usage is above threshold!"
fi

if [[ $MEM_USAGE -gt $MEM_THRESHOLD ]]; then
    print_warning "Memory usage is above threshold!"
fi

print_status "System monitoring completed!"'''
            },
            
            'backup-automation': {
                'description': 'Automated backup script',
                'template': '''#!/bin/bash

# Bash: Automated backup script
# Generated by BK25 - Enterprise automation without enterprise complexity

set -e
set -u

# Colors for output
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m'

# Error handling
trap 'echo -e "${{RED}}Error occurred. Cleaning up...${{NC}}"; exit 1' ERR

print_status() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

show_help() {{
    echo "Usage: $0 <source_path> <backup_destination> [OPTIONS]"
    echo "Description: Create automated backup of source path"
    echo ""
    echo "Arguments:"
    echo "  source_path         Path to backup"
    echo "  backup_destination  Destination for backup"
    echo ""
    echo "Options:"
    echo "  -h, --help          Show this help message"
    echo "  -c, --compress      Compress backup (gzip)"
    echo "  -d, --delete-old    Delete backups older than 7 days"
    echo ""
    echo "Example: $0 /home/user /backups --compress --delete-old"
    exit 0
}}

# Parse arguments
if [[ $# -lt 2 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
fi

SOURCE_PATH="$1"
BACKUP_DEST="$2"
COMPRESS=false
DELETE_OLD=false

# Parse options
shift 2
while [[ $# -gt 0 ]]; do
    case $1 in
        -c|--compress)
            COMPRESS=true
            shift
            ;;
        -d|--delete-old)
            DELETE_OLD=true
            shift
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            ;;
    esac
done

# Validate source path
if [[ ! -e "$SOURCE_PATH" ]]; then
    print_error "Source path does not exist: $SOURCE_PATH"
    exit 1
fi

# Create backup destination if it doesn't exist
mkdir -p "$BACKUP_DEST"

# Generate backup filename
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
SOURCE_NAME=$(basename "$SOURCE_PATH")
BACKUP_NAME="backup_${SOURCE_NAME}_${TIMESTAMP}"

if [[ "$COMPRESS" == true ]]; then
    BACKUP_NAME="${BACKUP_NAME}.tar.gz"
    print_status "Creating compressed backup: $BACKUP_NAME"
    tar -czf "$BACKUP_DEST/$BACKUP_NAME" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
else
    BACKUP_NAME="${BACKUP_NAME}.tar"
    print_status "Creating backup: $BACKUP_NAME"
    tar -cf "$BACKUP_DEST/$BACKUP_NAME" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
fi

print_status "Backup completed: $BACKUP_DEST/$BACKUP_NAME"

# Delete old backups if requested
if [[ "$DELETE_OLD" == true ]]; then
    print_status "Cleaning up old backups..."
    find "$BACKUP_DEST" -name "backup_${SOURCE_NAME}_*" -mtime +7 -delete
    print_status "Old backups cleaned up"
fi

print_status "Backup automation completed successfully!"'''
            },
            
            'service-management': {
                'description': 'Service management script',
                'template': '''#!/bin/bash

# Bash: Service management script
# Generated by BK25 - Enterprise automation without enterprise complexity

set -e
set -u

# Colors for output
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m'

# Error handling
trap 'echo -e "${{RED}}Error occurred. Cleaning up...${{NC}}"; exit 1' ERR

print_status() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

print_error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

show_help() {{
    echo "Usage: $0 <service_name> <action> [OPTIONS]"
    echo "Description: Manage system services"
    echo ""
    echo "Arguments:"
    echo "  service_name  Name of the service to manage"
    echo "  action        Action to perform (start|stop|restart|status|enable|disable)"
    echo ""
    echo "Options:"
    echo "  -h, --help    Show this help message"
    echo "  -v, --verbose Enable verbose output"
    echo ""
    echo "Examples:"
    echo "  $0 nginx start"
    echo "  $0 apache2 restart --verbose"
    exit 0
}}

# Parse arguments
if [[ $# -lt 2 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
fi

SERVICE_NAME="$1"
ACTION="$2"
VERBOSE=false

# Parse options
shift 2
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            ;;
    esac
done

# Validate action
VALID_ACTIONS=("start" "stop" "restart" "status" "enable" "disable")
if [[ ! " ${{VALID_ACTIONS[*]}} " =~ " $ACTION " ]]; then
    print_error "Invalid action: $ACTION"
    print_error "Valid actions: ${{VALID_ACTIONS[*]}}"
    exit 1
fi

print_status "Managing service: $SERVICE_NAME"
print_status "Action: $ACTION"

# Check if service exists
if ! systemctl list-unit-files | grep -q "^$SERVICE_NAME.service"; then
    print_error "Service not found: $SERVICE_NAME"
    exit 1
fi

# Perform action
case $ACTION in
    start)
        print_status "Starting $SERVICE_NAME..."
        systemctl start "$SERVICE_NAME"
        ;;
    stop)
        print_status "Stopping $SERVICE_NAME..."
        systemctl stop "$SERVICE_NAME"
        ;;
    restart)
        print_status "Restarting $SERVICE_NAME..."
        systemctl restart "$SERVICE_NAME"
        ;;
    status)
        print_status "Checking status of $SERVICE_NAME..."
        systemctl status "$SERVICE_NAME"
        ;;
    enable)
        print_status "Enabling $SERVICE_NAME..."
        systemctl enable "$SERVICE_NAME"
        ;;
    disable)
        print_status "Disabling $SERVICE_NAME..."
        systemctl disable "$SERVICE_NAME"
        ;;
esac

print_status "Service management completed successfully!"'''
            }
        }
    
    def validate_script(self, script: str) -> ScriptValidation:
        """Validate generated Bash script"""
        issues = []
        suggestions = []
        
        # Check for basic Bash structure
        if not re.search(r'set -e|trap.*ERR', script, re.IGNORECASE):
            issues.append('Script lacks proper error handling')
            suggestions.append('Include set -e and trap for error handling')
        
        # Check for shebang
        if not script.startswith('#!/bin/bash'):
            issues.append('Script lacks proper shebang')
            suggestions.append('Start script with #!/bin/bash')
        
        # Check for parameter validation
        if re.search(r'\$[0-9]', script) and not re.search(r'if.*\$#|show_help', script, re.IGNORECASE):
            issues.append('Script uses positional parameters but lacks validation')
            suggestions.append('Add parameter validation and help function')
        
        # Check for user feedback
        if not re.search(r'echo|print_status|print_info', script, re.IGNORECASE):
            issues.append('Script provides no user feedback')
            suggestions.append('Add echo statements or print functions for user feedback')
        
        # Check for help function
        if not re.search(r'show_help|usage', script, re.IGNORECASE):
            suggestions.append('Consider adding a help/usage function')
        
        # Check for executable permissions guidance
        if not re.search(r'chmod|executable', script, re.IGNORECASE):
            suggestions.append('Consider adding chmod guidance in comments')
        
        return ScriptValidation(
            is_valid=len(issues) == 0,
            issues=issues,
            suggestions=suggestions
        )
    
    def get_common_commands(self) -> Dict[str, List[str]]:
        """Get common Bash commands by category"""
        return {
            'file-system': [
                'ls', 'cp', 'mv', 'rm', 'mkdir', 'rmdir', 'find', 'grep',
                'cat', 'head', 'tail', 'less', 'more', 'touch', 'chmod', 'chown'
            ],
            'system-management': [
                'ps', 'top', 'htop', 'systemctl', 'service', 'kill', 'killall',
                'pgrep', 'pkill', 'free', 'df', 'du', 'uptime', 'uname'
            ],
            'networking': [
                'ping', 'curl', 'wget', 'ssh', 'scp', 'rsync', 'netstat',
                'ss', 'ip', 'ifconfig', 'route', 'dig', 'nslookup'
            ],
            'text-processing': [
                'awk', 'sed', 'cut', 'sort', 'uniq', 'wc', 'tr', 'paste',
                'join', 'split', 'xargs', 'tee', 'column'
            ],
            'package-management': [
                'apt', 'apt-get', 'yum', 'dnf', 'pacman', 'zypper',
                'snap', 'flatpak', 'brew', 'pip', 'npm'
            ],
            'backup-compression': [
                'tar', 'gzip', 'gunzip', 'bzip2', 'bunzip2', 'zip', 'unzip',
                'rsync', 'dd', 'cpio', 'dump', 'restore'
            ]
        }
    
    def get_common_options(self) -> List[str]:
        """Get common Bash script options"""
        return [
            '--help', '--version', '--verbose', '--quiet', '--debug',
            '--dry-run', '--force', '--interactive', '--recursive',
            '--all', '--long', '--human-readable', '--color'
        ]
    
    def get_system_variables(self) -> List[str]:
        """Get common system environment variables"""
        return [
            'PATH', 'HOME', 'USER', 'SHELL', 'PWD', 'OLDPWD',
            'HOSTNAME', 'HOSTTYPE', 'OSTYPE', 'MACHTYPE',
            'LANG', 'LC_ALL', 'TZ', 'TERM', 'EDITOR'
        ]
